#!/bin/bash

# Gemini Toolbox Wrapper Script
# A zero-config, ultra-secure home for your Gemini AI agent.

# 0. Global Defaults & Functions (Source-safe)
# These are safe to load when sourcing the script for testing.

# Default Docker Hub account for official images. 
# Overridable via DOCKER_HUB_USER environment variable.
DOCKER_HUB_USER="${DOCKER_HUB_USER:-jsebayhi}"

# Logging Configuration
# Levels: 0=ERROR, 1=WARN, 2=INFO, 3=DEBUG
LOG_LEVEL="${LOG_LEVEL:-2}"

_log() {
    local level_name="$1"
    local level_val="$2"
    shift 2
    if [ "$LOG_LEVEL" -ge "$level_val" ]; then
        if [ "$level_val" -eq 0 ]; then
            # ERROR: Use standard Error: prefix
            echo "Error: $*" >&2
        elif [ "$level_val" -eq 1 ]; then
            # WARN
            echo "Warning: $*" >&2
        else
            # INFO and DEBUG: Use the stylized prefix
            echo ">> $*" >&2
        fi
    fi
}

log_error() { _log "ERROR" 0 "$@"; }
log_warn()  { _log "WARN"  1 "$@"; }
log_info()  { _log "INFO"  2 "$@"; }
log_debug() { _log "DEBUG" 3 "$@"; }

show_help() {
    echo "Usage: gemini-toolbox [OPTIONS] [-- APP_ARGS]"
    echo ""
    echo "Options:"
    echo "  --preview            Use the preview image (Latest Beta CLI)"
    echo "  --image <name>       Override the Docker image to use"
    echo "  --no-ide             Disable VS Code integration (bypass companion extension)"
    echo "  --no-docker          Disable Docker-out-of-Docker integration (Sandbox Mode)"
    echo "  --config <path>      Path to configuration directory (default: ~/.gemini)"
    echo "  --profile <path>     Use a configuration profile (isolated .gemini + extra-args)"
    echo "  --project <path>     Path to project directory to mount as workspace (default: current dir)"
    echo "  --docker-args <str>  Additional arguments passed to 'docker run' (e.g., mounts)"
    echo "  --remote <key>       Enable Tailscale VPN for remote access (Container Mode)"
    echo "  --worktree [arg]     Launch in an isolated Git Worktree. Arg can be name or task."
    echo "  --name <str>         Explicit name for the worktree folder and branch."
    echo "  --bash               Start a bash shell instead of the Gemini CLI"
    echo "  --no-tmux            Disable automatic tmux multiplexing (legacy raw TTY mode)"
    echo "  --detached           Start the container in background and exit (useful for Hub)"
    echo "  --help               Show this help message"
    echo ""
    echo "Commands:"
    echo "  update               Force update the Docker image from the registry"
    echo "  stop-hub             Stop the background Gemini Hub service"
    echo "  stop [id|project]    Stop session (defaults to current project)"
    echo "  connect <id>         Attach to a running background session"
    echo ""
    echo "Examples:"
    echo "  gemini-toolbox chat"
    echo "  gemini-toolbox --remote tskey-auth-xxxx chat"
    echo "  gemini-toolbox --worktree \"Refactor auth\""
}

# Worktree Setup Function
# Arguments:
#   $1: Project Name
#   $2: Target Name (Branch/Folder)
#   $3: Current Project Dir
# Returns:
#   New Project Directory path
setup_worktree() {
    local project_name="$1"
    local target_name="$2"
    # shellcheck disable=SC2034 # current_project_dir is passed for API symmetry
    local current_project_dir="$3"

    local worktree_base="${XDG_CACHE_HOME:-$HOME/.cache}/gemini-toolbox/worktrees/${project_name}"
    worktree_base="${GEMINI_WORKTREE_ROOT:-$worktree_base}"
    
    local branch_name=""
    local folder_name=""

    if ! command -v git &> /dev/null; then
        log_error "'git' is required for --worktree but not found." >&2
        exit 1
    fi

    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        log_error "--worktree can only be used within a Git repository." >&2
        exit 1
    fi

    if ! git rev-parse --verify HEAD >/dev/null 2>&1; then
        log_error "Cannot create a worktree from an empty repository." >&2
        exit 1
    fi

    if [ -f "$(git rev-parse --show-toplevel)/.git" ]; then
        log_error "--worktree is not supported from within another worktree." >&2
        exit 1
    fi

    # Resolve Identity
    if [[ -n "$target_name" ]]; then
        branch_name="$target_name"
        folder_name="${branch_name//\//-}"
        folder_name=$(echo "$folder_name" | tr -cd '[:alnum:]-._')
        log_info "Worktree: Using explicit name '$branch_name'"
    else
        local uuid
        uuid=$(head -c 8 /proc/sys/kernel/random/uuid 2>/dev/null || date +%s)
        folder_name="exploration-${uuid}"
        log_info "Worktree: Anonymous Exploration (Detached HEAD)"
    fi

    local worktree_path="${worktree_base}/${folder_name}"

    # Create Worktree
    if [ -d "$worktree_path" ]; then
        log_info "Worktree already exists at: $worktree_path"
    else
        log_info "Creating worktree at: $worktree_path"
        mkdir -p "$(dirname "$worktree_path")"
        
        if [[ -n "$branch_name" ]]; then
            if git show-ref --verify --quiet "refs/heads/$branch_name"; then
                git worktree add "$worktree_path" "$branch_name" >&2 || { log_error "Failed to create git worktree."; exit 1; }
            else
                git worktree add -b "$branch_name" "$worktree_path" >&2 || { log_error "Failed to create git worktree."; exit 1; }
            fi
        else
            git worktree add --detach "$worktree_path" HEAD >&2 || { log_error "Failed to create git worktree."; exit 1; }
        fi
    fi
    
    echo "$worktree_path"
}

# Main Execution Logic
main() {
    set -euo pipefail

    # 0.1 Resolve Script Location
    local real_source="${BASH_SOURCE[0]}"
    while [ -h "$real_source" ]; do
        local dir
        dir="$( cd -P "$( dirname "$real_source" )" >/dev/null 2>&1 && pwd )"
        real_source="$(readlink "$real_source")"
        [[ $real_source != /* ]] && real_source="$dir/$real_source"
    done
    local script_dir
    script_dir="$( cd -P "$( dirname "$real_source" )" >/dev/null 2>&1 && pwd )"
    local repo_root
    repo_root="$(dirname "$script_dir")"

    # 0.2 Initialize Configuration
    export HOST_CONF_DIR="${HOME}/.gemini"
    local project_dir
    project_dir="$(pwd)"
    
    local variant="latest"
    local use_bash=false
    
    local enable_vscode_integration=false
    if [[ "${TERM_PROGRAM:-}" == "vscode" ]]; then
        enable_vscode_integration=true
    fi

    local extra_docker_args=()
    
    # 0.3 Pre-scan for Config/Profile & Load Extra Args
    local temp_conf="$HOST_CONF_DIR"
    local enable_profile_mode=false
    local has_config=false
    local has_profile=false

    local iter_args=("$@")
    for ((i=0; i<${#iter_args[@]}; i++)); do
        case "${iter_args[i]}" in
            --config)
                temp_conf="${iter_args[i+1]}"
                enable_profile_mode=false
                has_config=true
                ;;
            --profile)
                temp_conf="${iter_args[i+1]}"
                enable_profile_mode=true
                has_profile=true
                ;;
        esac
    done

    if [ "$has_config" = true ] && [ "$has_profile" = true ]; then
        log_error "Cannot use both --config and --profile simultaneously." >&2
        exit 1
    fi

    if ! command -v realpath &> /dev/null; then
         log_error "'realpath' is required. Please install coreutils." >&2
         exit 1
    fi
    temp_conf=$(realpath -m "$temp_conf")
    
    local file_args=()
    if [ "$enable_profile_mode" = true ] && [ -f "${temp_conf}/extra-args" ]; then
        log_info "Loading profile args from ${temp_conf}/extra-args"
        while IFS= read -r line || [ -n "$line" ]; do
            line="${line#"${line%%[![:space:]]*}"}"
            if [[ -n "$line" && ! "$line" =~ ^# ]]; then
                 local parts=()
                 # Use eval to properly parse quotes arguments (like shell would)
                 eval "parts=($line)"
                 file_args+=("${parts[@]}")
            fi
        done < "${temp_conf}/extra-args"
    fi

    if [ ${#file_args[@]} -gt 0 ]; then
        set -- "${file_args[@]}" "$@"
    fi

    # 1. Pre-scan for Variant & Override Image
    local override_image=""
    local iter_variant_args=("$@")
    for ((i=0; i<${#iter_variant_args[@]}; i++)); do
        case "${iter_variant_args[i]}" in
            --preview) variant="preview" ;;
            --image)   override_image="${iter_variant_args[i+1]}" ;;
        esac
    done

    # 2. Resolve Image Name
    local branch_suffix=""
    if command -v git >/dev/null 2>&1 && git -C "$repo_root" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        local current_branch
        current_branch=$(git -C "$repo_root" rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ "$current_branch" != "main" ] && [ -n "$current_branch" ]; then
            local safe_branch="${current_branch//[!a-zA-Z0-9]/-}"
            branch_suffix="-$safe_branch"
        fi
    fi

    local local_tag=""
    local remote_tag=""
    local local_fallback_tag=""
    local image_name=""
    
    if [ -n "$override_image" ]; then
        image_name="$override_image"
    elif [ "$variant" == "preview" ]; then
        local_tag="gemini-cli-toolbox/cli-preview:latest${branch_suffix}"
        local_fallback_tag="gemini-cli-toolbox/cli-preview:latest"
        remote_tag="${DOCKER_HUB_USER}/gemini-cli-toolbox:latest-preview"
    else
        local_tag="gemini-cli-toolbox/cli:latest${branch_suffix}"
        local_fallback_tag="gemini-cli-toolbox/cli:latest"
        remote_tag="${DOCKER_HUB_USER}/gemini-cli-toolbox:latest-stable"
    fi

    if [ -z "$image_name" ]; then
        if docker image inspect "$local_tag" >/dev/null 2>&1; then
            image_name="$local_tag"
        elif [ -n "$branch_suffix" ] && docker image inspect "$local_fallback_tag" >/dev/null 2>&1; then
            # Fallback: User is on a branch but hasn't built it, use their local main build
            image_name="$local_fallback_tag"
        else
            image_name="$remote_tag"
        fi
    fi
    local args=()
    local remote_mode=false
    local no_tmux_flag=false
    local tailscale_key="${GEMINI_REMOTE_KEY:-}"
    local enable_docker=true
    local detached_mode=false
    local force_update=false
    local stop_hub=false
    local stop_command_executed=false
    local stop_session_target=""
    local connect_id=""
    local enable_worktree=false
    local arg_name=""

    while [[ $# -gt 0 ]]; do
      case $1 in
        --preview)     variant="preview"; shift ;;
        --image)       override_image="$2"; shift; shift ;;
        --no-ide)      enable_vscode_integration=false;   shift ;;
        --no-docker)   enable_docker=false;               shift ;;
        --no-tmux)     extra_docker_args+=("--env" "GEMINI_TOOLBOX_TMUX=false"); no_tmux_flag=true; shift ;;
        --config)      HOST_CONF_DIR="$2"; shift; shift ;;
        --profile)     HOST_CONF_DIR="$2"; enable_profile_mode=true; shift; shift ;;
        --project)     project_dir="$2";   shift; shift ;;
        --bash)        use_bash=true;      shift ;;
        --detached)    detached_mode=true; shift ;;
        --remote)      
            remote_mode=true
            if [[ -n "${2:-}" && "$2" == tskey-* ]]; then
                tailscale_key="$2"
                shift
            fi
            shift 
            ;;
        --worktree)    enable_worktree=true; shift ;;
        --name)        arg_name="$2"; shift; shift ;;
        --docker-args) 
            IFS=' ' read -r -a split_args <<< "$2"
            extra_docker_args+=("${split_args[@]}")
            shift; shift 
            ;;
        -v|--volume)   extra_docker_args+=("--volume" "$2"); shift; shift ;;
        --help)        show_help; exit 0 ;;
        update)        force_update=true; shift ;;
        stop-hub)      stop_hub=true; shift ;;
        stop)
            stop_command_executed=true
            if [[ -n "${2:-}" && "$2" != --* ]]; then
                stop_session_target="$2"
                shift; shift
            else
                shift
            fi
            ;;
        connect)       connect_id="$2"; shift; shift ;;
        --)            shift; args+=("$@"); break ;;
        *)             args+=("$1");       shift ;;
      esac
    done

    if [ "$remote_mode" = true ] && [ "$no_tmux_flag" = true ]; then
        log_error "--remote and --no-tmux are incompatible." >&2
        exit 1
    fi

    HOST_CONF_DIR=$(realpath -m "$HOST_CONF_DIR")
    local profile_root=""
    if [ "$enable_profile_mode" = true ]; then
        profile_root="$HOST_CONF_DIR"
        HOST_CONF_DIR="${HOST_CONF_DIR}/.gemini"
    fi
    mkdir -p "$HOST_CONF_DIR"

    local required_dirs=(
        "${HOME}/.m2" "${HOME}/.gradle" "${HOME}/.sbt" "${HOME}/.ivy2"
        "${HOME}/.cache/coursier" "${HOME}/go/pkg/mod" "${HOME}/.cache/go-build"
    )
    for dir in "${required_dirs[@]}"; do
        if [ ! -d "$dir" ]; then mkdir -p "$dir"; fi
    done

    project_dir=$(realpath -m "$project_dir")
    if [ ! -d "$project_dir" ]; then
        log_error "Project directory '$project_dir' does not exist." >&2
        exit 1
    fi

    local project_name
    if [ -n "$arg_name" ]; then
        project_name="$arg_name"
    else
        project_name=$(basename "$project_dir" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
    fi

    local session_type="geminicli"
    if [ "$use_bash" = true ]; then session_type="bash"; fi

    local gen_uuid=""
    if [ -f /proc/sys/kernel/random/uuid ]; then
        gen_uuid=$(head -c 36 /proc/sys/kernel/random/uuid | cut -c1-8)
    fi
    gen_uuid="${gen_uuid:-$(date +%s)}"

    local gemini_session_id="gem-${project_name}-${session_type}-${gen_uuid}"
    local container_name_arg=("--name" "${gemini_session_id}")

    local original_project_dir="$project_dir"
    if [ "$enable_worktree" = true ]; then
        # Capture output separately to honor set -e
        local new_wt
        new_wt=$(setup_worktree "$project_name" "$arg_name" "$project_dir")
        project_dir="$new_wt"
    fi

    if [ "$force_update" = true ]; then
        if [[ "$image_name" == "$local_tag" ]]; then
            log_error "You are using a local image '$local_tag'. Cannot update from registry."
            exit 1
        fi
        log_info "Updating '$image_name'..."
        if ! docker pull "$image_name"; then
            log_error "Failed to pull image '$image_name' from registry."
            exit 1
        fi
        exit 0
    fi

    if [ "$stop_hub" = true ]; then
        local hub_script="${script_dir}/gemini-hub"
        if [ -x "$hub_script" ]; then exec "$hub_script" stop; else exit 1; fi
    fi

    if [ "$stop_command_executed" = true ]; then
        stop_session_target="${stop_session_target:-$project_name}"
        local matches=""
        if docker ps --format '{{.Names}}' | grep -q "^${stop_session_target}$"; then
            matches="${stop_session_target}"
        else
            matches=$(docker ps --format '{{.Names}}' --filter "name=gem-${stop_session_target}-" | grep -E "^gem-${stop_session_target}-" || true)
        fi
        if [ -z "$matches" ]; then log_error "No active sessions found matching '$stop_session_target'." >&2; exit 1; fi
        local match_count
        match_count=$(echo "$matches" | wc -l)
        if [ "$match_count" -gt 1 ]; then
            log_error "Multiple sessions found for project '$stop_session_target':" >&2
            # shellcheck disable=SC2001
            echo "$matches" | sed 's/^/   - /' >&2
            echo "" >&2
            echo "Please specify a full session ID to stop a specific one." >&2
            exit 1
        fi
        log_info "Stopping session: $matches"
        docker stop "$matches"
        exit $?
    fi

    if [ -n "$connect_id" ]; then
        log_info "Connecting to session '$connect_id'..."
        if [ -z "$(docker ps -q -f name="^/${connect_id}$")" ]; then
             log_error "Session '$connect_id' not found."
             exit 1
        fi
        local current_uid
        current_uid=$(id -u)
        if [[ "$connect_id" == *"-bash-"* ]]; then
             exec docker exec -it "$connect_id" gosu "$current_uid" bash
        else
             if docker exec "$connect_id" gosu "$current_uid" tmux has-session -t gemini 2>/dev/null; then
                 exec docker exec -it "$connect_id" gosu "$current_uid" tmux attach -t gemini
             else
                 log_error "Reconnecting to this session is not supported." >&2
                 exit 1
             fi
        fi
    fi

    if [[ "$image_name" == *"$remote_tag"* ]] && [[ "$image_name" == *"latest"* ]] && docker image inspect "$image_name" >/dev/null 2>&1; then
        local created
        created=$(docker inspect --format='{{.Created}}' "$image_name")
        local created_sec
        created_sec=$(date -d "$created" +%s 2>/dev/null || echo "0")
        local age=$(( ($(date +%s) - created_sec) / 86400 ))
        if [ "$age" -ge 7 ]; then
             log_info "Tip: Your Gemini image is $age days old. Run 'gemini-toolbox update' to refresh."
        fi
    fi

    local host_docker_gid=""
    if [ "$enable_docker" = true ]; then
        if command -v getent >/dev/null 2>&1 && getent group docker >/dev/null 2>&1; then
            host_docker_gid=$(getent group docker | cut -d: -f3)
        fi
    fi

    local network_mode="--net=host"
    if [ "$remote_mode" = true ]; then
        if [ -z "$tailscale_key" ]; then
            log_error "TAILSCALE_KEY is required for --remote mode." >&2
            exit 1
        fi
        local hub_name="gemini-hub-service"
        if [ -z "$(docker ps -q -f name="^/${hub_name}$")" ]; then
            local hub_script="${script_dir}/gemini-hub"
            if [ -x "$hub_script" ]; then
                 local hub_args=("-d" "--key" "$tailscale_key" "--workspace" "$project_dir")
                 if [ "$enable_profile_mode" = true ] && [ -n "$profile_root" ]; then
                     local hub_config_root
                     hub_config_root=$(dirname "$profile_root")
                     if [ -t 0 ]; then
                         read -p ">> Allow Hub to scan parent directory? [y/N] " -n 1 -r REPLY
                         if [[ ${REPLY:-N} =~ ^[Yy]$ ]]; then hub_args+=("--config-root" "$hub_config_root"); fi
                     fi
                 fi
                 "$hub_script" "${hub_args[@]}" > /tmp/gemini-hub.log 2>&1 || true
            fi
        fi
        network_mode="--network=bridge"
        enable_vscode_integration=false
        extra_docker_args+=(
            --env TAILSCALE_AUTH_KEY="$tailscale_key"
            --cap-add=NET_ADMIN --device /dev/net/tun -p 127.0.0.1:0:3000
        )
    fi

    local docker_args=(
      "${container_name_arg[@]}" "$network_mode" --volume "${project_dir}:${project_dir}"
    )

    local main_repo_root=""
    if [ "$project_dir" != "$original_project_dir" ]; then
        main_repo_root="$original_project_dir"
    elif command -v git >/dev/null 2>&1 && git -C "$project_dir" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        local toplevel
        toplevel=$(git -C "$project_dir" rev-parse --show-toplevel 2>/dev/null)
        if [ -f "${toplevel}/.git" ]; then
            local common_dir
            common_dir=$(git -C "$project_dir" rev-parse --git-common-dir 2>/dev/null)
            if [ -n "$common_dir" ]; then main_repo_root=$(dirname "$common_dir"); fi
        fi
    fi

    if [ -n "$main_repo_root" ]; then
        docker_args+=(--volume "${main_repo_root}:${main_repo_root}:ro" --volume "${main_repo_root}/.git:${main_repo_root}/.git")
    fi

    docker_args+=(
        --volume "${HOST_CONF_DIR}:/home/gemini/.gemini"
        --volume "${HOME}/.m2:/home/gemini/.m2" --volume "${HOME}/.gradle:/home/gemini/.gradle"
        --volume "${HOME}/.sbt:/home/gemini/.sbt" --volume "${HOME}/.ivy2:/home/gemini/.ivy2"
        --volume "${HOME}/.cache/coursier:/home/gemini/.cache/coursier"
        --volume "${HOME}/go/pkg/mod:/home/gemini/go/pkg/mod"
        --volume "${HOME}/.cache/go-build:/home/gemini/.cache/go-build"
        --env DEFAULT_UID="${HOST_UID:-$(id -u)}" --env DEFAULT_GID="${HOST_GID:-$(id -g)}"
        --env GEMINI_SESSION_ID="${gemini_session_id}" --env GEMINI_PROJECT_NAME="${project_name}"
        --env GEMINI_SESSION_TYPE="${session_type}" --env TERM="${TERM:-xterm-256color}"
        --env COLORTERM --env LANG --env LC_ALL
        --env HTTP_PROXY --env HTTPS_PROXY --env NO_PROXY
        --env http_proxy --env https_proxy --env no_proxy
        --workdir "${project_dir}" "${extra_docker_args[@]}"
    )

    if [ "$enable_docker" = true ]; then
        docker_args+=(--volume "/var/run/docker.sock:/var/run/docker.sock" --env HOST_DOCKER_GID="${host_docker_gid}")
    fi

    if [ "$enable_vscode_integration" = true ]; then
        docker_args+=(
          --env TERM_PROGRAM --env TERM_PROGRAM_VERSION
          --env GEMINI_CLI_IDE_SERVER_PORT --env GEMINI_CLI_IDE_AUTH_TOKEN
          --env GEMINI_CLI_IDE_WORKSPACE_PATH
          --env GEMINI_CLI_IDE_SERVER_HOST=127.0.0.1
        )
    fi

    local exec_args=()
    if [ "$use_bash" = true ]; then
        log_info "Mode: BASH"
        exec_args=("--entrypoint" "/usr/local/bin/docker-entrypoint.sh" "$image_name" "bash" "${args[@]}")
    else
        exec_args=("$image_name" "${args[@]}")
    fi

    if [ "$detached_mode" = true ]; then
        log_info "Starting container in background..."
        docker run --rm -d "${docker_args[@]}" "${exec_args[@]}"
        log_info "Container started: ${gemini_session_id}"
    else
        if [ "$use_bash" = true ]; then echo "Starting in BASH mode..."; fi
        docker run --rm -it "${docker_args[@]}" "${exec_args[@]}"
    fi
}

# Entry point guard
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
