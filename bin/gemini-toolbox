#!/bin/bash

# Configuration
HOST_CONF_DIR="${HOME}/.gemini"
PROJECT_DIR="$(pwd)"
DOCKER_HUB_USER="${DOCKER_HUB_USER:-jsebayhi}" # Allow override via env var
VARIANT="latest"
USE_BASH=false

# Auto-detect VS Code environment
if [[ "$TERM_PROGRAM" == "vscode" ]]; then
    ENABLE_VSCODE_INTEGRATION=true
else
    ENABLE_VSCODE_INTEGRATION=false
fi

EXTRA_DOCKER_ARGS=()

# Help Function
show_help() {
    echo "Usage: gemini-toolbox [OPTIONS] [-- APP_ARGS]"
    echo ""
    echo "Options:"
    echo "  --full               Use the full image (Java 8/17/21, Go, Scala)"
    echo "  --preview            Use the preview image (Latest Beta CLI)"
    echo "  --no-ide             Disable VS Code integration (bypass companion extension)"
    echo "  --no-docker          Disable Docker-out-of-Docker integration (Sandbox Mode)"
    echo "  --config <path>      Path to configuration directory (default: ~/.gemini)"
    echo "  --project <path>     Path to project directory to mount as workspace (default: current dir)"
    echo "  --docker-args <str>  Additional arguments passed to 'docker run' (e.g., mounts)"
    echo "  --remote <key>       Enable Tailscale VPN for remote access (Container Mode)"
    echo "  --bash               Start a bash shell instead of the Gemini CLI"
    echo "  --help               Show this help message"
    echo ""
    echo "Commands:"
    echo "  update               Force update the Docker image from the registry"
    echo ""
    echo "Examples:"
    echo "  gemini-toolbox chat"
    echo "  gemini-toolbox --remote tskey-auth-xxxx chat"
    echo "  gemini-toolbox --config ~/.gemini-work -- --help"
}

# 1. Parse Arguments
ARGS=()
REMOTE_MODE=false
TAILSCALE_KEY="${GEMINI_REMOTE_KEY:-}"
ENABLE_DOCKER=true

while [[ $# -gt 0 ]]; do
  case $1 in
    --full)        VARIANT="full"; shift ;;
    --preview)     VARIANT="preview"; shift ;;
    --no-ide)      ENABLE_VSCODE_INTEGRATION=false;   shift ;;
    --no-docker)   ENABLE_DOCKER=false;               shift ;;
    --config)      HOST_CONF_DIR="$2"; shift; shift ;;
    --project)     PROJECT_DIR="$2";   shift; shift ;;
    --bash)        USE_BASH=true;      shift ;;
    --remote)      
        REMOTE_MODE=true
        # Optional argument: Check if next arg exists AND starts with 'tskey-'
        if [[ -n "$2" && "$2" == tskey-* ]]; then
            TAILSCALE_KEY="$2"
            shift
        fi
        shift 
        ;;
    --docker-args) 
        read -ra SPLIT_ARGS <<< "$2"
        EXTRA_DOCKER_ARGS+=("${SPLIT_ARGS[@]}")
        shift; shift 
        ;;
    -v|--volume)
        EXTRA_DOCKER_ARGS+=("-v" "$2")
        shift; shift
        ;;
    --help)        show_help; exit 0 ;;
    update)        FORCE_UPDATE=true; shift ;;
    --)            shift; ARGS+=("$@"); break ;;
    *)             ARGS+=("$1");       shift ;;
  esac
done

# 2. Setup Directories
# ... (rest of the directory setup logic) ...
# (I'll keep the context small for the replacement tool)
HOST_CONF_DIR=$(realpath -m "$HOST_CONF_DIR")
mkdir -p "$HOST_CONF_DIR"

# 2.1 Pre-create Host Cache Directories (As User)
# We do this to prevent Docker from creating them as 'root' if they don't exist
REQUIRED_DIRS=(
    "${HOME}/.m2"
    "${HOME}/.gradle"
    "${HOME}/.sbt"
    "${HOME}/.ivy2"
    "${HOME}/.cache/coursier"
    "${HOME}/go/pkg/mod"
    "${HOME}/.cache/go-build"
)

for dir in "${REQUIRED_DIRS[@]}"; do
    if [ ! -d "$dir" ]; then
        # echo "Initializing missing cache directory: $dir"
        mkdir -p "$dir"
    fi
done

PROJECT_DIR=$(realpath -m "$PROJECT_DIR")
if [ ! -d "$PROJECT_DIR" ]; then
    echo "Error: Project directory '$PROJECT_DIR' does not exist." >&2
    exit 1
fi

# Extract project name for prettier mount point
PROJECT_NAME=$(basename "$PROJECT_DIR")

# Generate readable unique container name
CONTAINER_NAME_ARG=()
if [ -f /proc/sys/kernel/random/uuid ]; then
    GEN_UUID=$(head -c 36 /proc/sys/kernel/random/uuid | cut -c1-8)
    CONTAINER_NAME="${PROJECT_NAME}-${GEN_UUID}"
    CONTAINER_NAME_ARG=("--name" "${CONTAINER_NAME}")
fi

# 2.2 Resolve Image Name (Local vs Remote)
if [ "$VARIANT" == "full" ]; then
    LOCAL_TAG="gemini-cli-toolbox/cli-full:latest"
    REMOTE_TAG="${DOCKER_HUB_USER}/gemini-cli-toolbox:latest-full"
elif [ "$VARIANT" == "preview" ]; then
    LOCAL_TAG="gemini-cli-toolbox/cli-preview:latest"
    REMOTE_TAG="${DOCKER_HUB_USER}/gemini-cli-toolbox:latest-preview"
else
    LOCAL_TAG="gemini-cli-toolbox/cli:latest"
    REMOTE_TAG="${DOCKER_HUB_USER}/gemini-cli-toolbox:latest-stable"
fi

# Check if local image exists
if docker image inspect "$LOCAL_TAG" >/dev/null 2>&1; then
    IMAGE_NAME="$LOCAL_TAG"
else
    # Fallback to remote image
    IMAGE_NAME="$REMOTE_TAG"
fi

# 2.3 Handle Explicit Update
if [ "$FORCE_UPDATE" = true ]; then
    if [[ "$IMAGE_NAME" == "$LOCAL_TAG" ]]; then
        echo ">> Error: You are using a local image '$LOCAL_TAG'. Cannot update from registry."
        echo ">> Run 'make rebuild' to update locally."
        exit 1
    fi
    echo ">> Updating '$IMAGE_NAME'..."
    docker pull "$IMAGE_NAME"
    exit $?
fi

# 2.4 Stale Image Warning
# Only if using remote image, it is a 'latest' tag, AND it is > 7 days old
if [[ "$IMAGE_NAME" == *"$REMOTE_TAG"* ]] && [[ "$IMAGE_NAME" == *"latest"* ]] && docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
    CREATED=$(docker inspect --format='{{.Created}}' "$IMAGE_NAME")
    CREATED_SEC=$(date -d "$CREATED" +%s 2>/dev/null || echo "0")
    NOW_SEC=$(date +%s)
    AGE=$(( (NOW_SEC - CREATED_SEC) / 86400 ))
    
    # 7 days
    if [ "$AGE" -ge 7 ]; then
         echo ">> Tip: Your Gemini image is $AGE days old. Run 'gemini-toolbox update' to refresh."
    fi
fi

# 2.5 Detect Host Docker GID (for DooD)
if [ "$ENABLE_DOCKER" = true ]; then
    HOST_DOCKER_GID=""
    if command -v getent >/dev/null 2>&1 && getent group docker >/dev/null 2>&1; then
        HOST_DOCKER_GID=$(getent group docker | cut -d: -f3)
    fi
fi

# 3. Build Docker Command
NETWORK_MODE="--net=host"
if [ "$REMOTE_MODE" = true ]; then
    if [ -z "$TAILSCALE_KEY" ]; then
        echo "Error: --remote specified but no Tailscale Key found."
        echo "Provide key via argument (--remote tskey-...) or environment (GEMINI_REMOTE_KEY)."
        exit 1
    fi
    echo ">> Remote Mode detected. Isolating network stack..."
    NETWORK_MODE="--network=bridge"
    ENABLE_VSCODE_INTEGRATION=false
    EXTRA_DOCKER_ARGS+=(
        --env TAILSCALE_AUTH_KEY="$TAILSCALE_KEY"
        --cap-add=NET_ADMIN
        --device /dev/net/tun
    )
fi

DOCKER_CMD=(
  docker run --rm -it "${CONTAINER_NAME_ARG[@]}"
  $NETWORK_MODE
  # Path Mirroring for IDE Security Check:
  # We mount the project at the EXACT SAME path as the host (not /home/gemini/workspace).
  # The Gemini CLI checks that PWD inside match the Workspace Path in VS Code.
  --volume "${PROJECT_DIR}:${PROJECT_DIR}"
  --volume "${HOST_CONF_DIR}:/home/gemini/.gemini"
  # Shared Host Caches (Performance & Convenience)
  --volume "${HOME}/.m2:/home/gemini/.m2"
  --volume "${HOME}/.gradle:/home/gemini/.gradle"
  --volume "${HOME}/.sbt:/home/gemini/.sbt"
  --volume "${HOME}/.ivy2:/home/gemini/.ivy2"
  --volume "${HOME}/.cache/coursier:/home/gemini/.cache/coursier"
  --volume "${HOME}/go/pkg/mod:/home/gemini/go/pkg/mod"
  --volume "${HOME}/.cache/go-build:/home/gemini/.cache/go-build"
  --env DEFAULT_UID="$(id -u)"
  --env DEFAULT_GID="$(id -g)"
  --env TERM
  --env LANG
  --env LC_ALL
  --env HTTP_PROXY --env HTTPS_PROXY --env NO_PROXY
  --env http_proxy --env https_proxy --env no_proxy
  --workdir "${PROJECT_DIR}"
  "${EXTRA_DOCKER_ARGS[@]}"
)

# Conditionally Add Docker Support
if [ "$ENABLE_DOCKER" = true ]; then
    DOCKER_CMD+=(
      # Docker-out-of-Docker Support
      --volume "/var/run/docker.sock:/var/run/docker.sock"
      --env HOST_DOCKER_GID="${HOST_DOCKER_GID}"
    )
fi

# Conditionally Add IDE Integration
if [ "$ENABLE_VSCODE_INTEGRATION" = true ]; then
    DOCKER_CMD+=(
      # VS Code Integration:
      # 1. TERM_PROGRAM*: Tells Gemini CLI we are inside VS Code (enables the feature).
      # 2. GEMINI_CLI_IDE_*: Connection details passed from the Host Terminal.
      #    - HOST=127.0.0.1: Our custom patch forces the CLI to use this instead of host.docker.internal.
      --env TERM_PROGRAM
      --env TERM_PROGRAM_VERSION
      --env GEMINI_CLI_IDE_SERVER_PORT
      --env GEMINI_CLI_IDE_AUTH_TOKEN
      --env GEMINI_CLI_IDE_WORKSPACE_PATH
      --env GEMINI_CLI_IDE_SERVER_HOST=127.0.0.1
    )
fi

# 4. Execute
if [ "$USE_BASH" = true ]; then
    echo "Starting in BASH mode..."
    "${DOCKER_CMD[@]}" \
      --entrypoint /usr/local/bin/docker-entrypoint.sh \
      "$IMAGE_NAME" bash "${ARGS[@]}"
else
    "${DOCKER_CMD[@]}" \
      "$IMAGE_NAME" "${ARGS[@]}"
fi
