#!/bin/bash

# 0. Resolve script location and Repository Root
# This ensures we detect the branch of the toolbox itself, even when run from another project.
REAL_SOURCE="${BASH_SOURCE[0]}"
while [ -h "$REAL_SOURCE" ]; do
    DIR="$( cd -P "$( dirname "$REAL_SOURCE" )" >/dev/null 2>&1 && pwd )"
    REAL_SOURCE="$(readlink "$REAL_SOURCE")"
    [[ $REAL_SOURCE != /* ]] && REAL_SOURCE="$DIR/$REAL_SOURCE"
done
SCRIPT_DIR="$( cd -P "$( dirname "$REAL_SOURCE" )" >/dev/null 2>&1 && pwd )"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"

# Configuration
HOST_CONF_DIR="${HOME}/.gemini"
PROJECT_DIR="$(pwd)"
DOCKER_HUB_USER="${DOCKER_HUB_USER:-jsebayhi}" # Allow override via env var
VARIANT="latest"
USE_BASH=false

# Auto-detect VS Code environment
if [[ "$TERM_PROGRAM" == "vscode" ]]; then
    ENABLE_VSCODE_INTEGRATION=true
else
    ENABLE_VSCODE_INTEGRATION=false
fi

EXTRA_DOCKER_ARGS=()

# Help Function
show_help() {
    echo "Usage: gemini-toolbox [OPTIONS] [-- APP_ARGS]"
    echo ""
    echo "Options:"
    echo "  --preview            Use the preview image (Latest Beta CLI)"
    echo "  --image <name>       Override the Docker image to use"
    echo "  --no-ide             Disable VS Code integration (bypass companion extension)"
    echo "  --no-docker          Disable Docker-out-of-Docker integration (Sandbox Mode)"
    echo "  --config <path>      Path to configuration directory (default: ~/.gemini)"
    echo "  --project <path>     Path to project directory to mount as workspace (default: current dir)"
    echo "  --docker-args <str>  Additional arguments passed to 'docker run' (e.g., mounts)"
    echo "  --remote <key>       Enable Tailscale VPN for remote access (Container Mode)"
    echo "  --worktree [arg]     Launch in an isolated Git Worktree. Arg can be name or task."
    echo "  --name <str>         Explicit name for the worktree folder and branch."
    echo "  --bash               Start a bash shell instead of the Gemini CLI"
    echo "  --detached           Start the container in background and exit (useful for Hub)"
    echo "  --help               Show this help message"
    echo ""
    echo "Commands:"
    echo "  update               Force update the Docker image from the registry"
    echo "  stop-hub             Stop the background Gemini Hub service"
    echo "  connect <id>         Attach to a running background session"
    echo ""
    echo "Examples:"
    echo "  gemini-toolbox chat"
    echo "  gemini-toolbox --remote tskey-auth-xxxx chat"
    echo "  gemini-toolbox --worktree \"Refactor auth\""
    echo "  gemini-toolbox --worktree -- \"Summarize this file\""
    echo "  gemini-toolbox --config ~/.gemini-work -- --help"
}

# Worktree Setup Function
setup_worktree() {
    local WORKTREE_BASE="${XDG_CACHE_HOME:-$HOME/.cache}/gemini-toolbox/worktrees/${PROJECT_NAME}"
    # Use environment variable if provided, otherwise default
    WORKTREE_BASE="${GEMINI_WORKTREE_ROOT:-$WORKTREE_BASE}"
    
    local BRANCH_NAME=""
    local FOLDER_NAME=""

    # Ensure git is available
    if ! command -v git &> /dev/null; then
        echo "Error: 'git' is required for --worktree but not found." >&2
        exit 1
    fi

    # Ensure we are in a git repository
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo "Error: --worktree can only be used within a Git repository." >&2
        exit 1
    fi

    # Ensure the repository has at least one commit (HEAD exists)
    if ! git rev-parse --verify HEAD >/dev/null 2>&1; then
        echo "Error: Cannot create a worktree from an empty repository." >&2
        echo "       Please create an initial commit (e.g., 'git commit --allow-empty -m \"Initial commit\"') and try again." >&2
        exit 1
    fi

    # Ensure we are NOT already in a worktree (.git is a file)
    if [ -f "$(git rev-parse --show-toplevel)/.git" ]; then
        echo "Error: --worktree is not supported from within another worktree." >&2
        echo "       Please run this command from the main repository." >&2
        exit 1
    fi

    # 1. Resolve Identity
    if [[ -n "$TARGET_NAME" ]]; then
        # Case A: Explicit Naming
        BRANCH_NAME="$TARGET_NAME"
        # Replace slashes with dashes for the filesystem folder
        FOLDER_NAME="${BRANCH_NAME//\//-}"
        # Sanitize to ensure it's filesystem safe
        FOLDER_NAME=$(echo "$FOLDER_NAME" | tr -cd '[:alnum:]-._')
        echo ">> Worktree: Using explicit name '$BRANCH_NAME'"
    else
        # Case B: Anonymous Exploration (Detached HEAD)
        local UUID
        UUID=$(head -c 8 /proc/sys/kernel/random/uuid 2>/dev/null || date +%s)
        FOLDER_NAME="exploration-${UUID}"
        echo ">> Worktree: Anonymous Exploration (Detached HEAD)"
    fi

    local WORKTREE_PATH="${WORKTREE_BASE}/${FOLDER_NAME}"

    # 2. Create Worktree
    if [ -d "$WORKTREE_PATH" ]; then
        echo ">> Worktree already exists at: $WORKTREE_PATH"
    else
        echo ">> Creating worktree at: $WORKTREE_PATH"
        mkdir -p "$(dirname "$WORKTREE_PATH")"
        
        if [[ -n "$BRANCH_NAME" ]]; then
            # Check if branch exists
            if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
                git worktree add "$WORKTREE_PATH" "$BRANCH_NAME"
            else
                git worktree add -b "$BRANCH_NAME" "$WORKTREE_PATH"
            fi
        else
            # Detached HEAD
            git worktree add --detach "$WORKTREE_PATH" HEAD
        fi
    fi
    
    # 3. Update Global PROJECT_DIR to point to worktree
    PROJECT_DIR="$WORKTREE_PATH"
}

# 0. Pre-scan for Config & Load Extra Args
# We scan CLI args for --config to locate the profile directory.
# Then we load 'extra-args' (if present) and prepend them to the argument list.
# This allows profiles to define toolbox flags (like --no-ide) in addition to docker args.
# 0. Pre-scan for Config/Profile & Load Extra Args
# We scan CLI args for --config or --profile to locate the directory.
# --profile: Use directory as root, mount .gemini subdir (ENABLE_PROFILE_MODE=true)
# --config: Use directory directly (ENABLE_PROFILE_MODE=false)
TEMP_CONF="$HOST_CONF_DIR"
ENABLE_PROFILE_MODE=false
HAS_CONFIG=false
HAS_PROFILE=false

iter_args=("$@")
for ((i=0; i<${#iter_args[@]}; i++)); do
    case "${iter_args[i]}" in
        --config)
            TEMP_CONF="${iter_args[i+1]}"
            ENABLE_PROFILE_MODE=false
            HAS_CONFIG=true
            ;;
        --profile)
            TEMP_CONF="${iter_args[i+1]}"
            ENABLE_PROFILE_MODE=true
            HAS_PROFILE=true
            ;;
    esac
done

# Guard against ambiguous usage
if [ "$HAS_CONFIG" = true ] && [ "$HAS_PROFILE" = true ]; then
    echo "Error: Cannot use both --config and --profile simultaneously." >&2
    echo "Choose one: --config for simple directory mount, or --profile for nested workspace." >&2
    exit 1
fi

# Resolve absolute path for check
TEMP_CONF=$(realpath -m "$TEMP_CONF")
FILE_ARGS=()

if [ "$ENABLE_PROFILE_MODE" = true ] && [ -f "${TEMP_CONF}/extra-args" ]; then
    echo ">> Loading profile args from ${TEMP_CONF}/extra-args"
    while IFS= read -r line || [ -n "$line" ]; do
        # Trim leading whitespace
        line="${line#"${line%%[![:space:]]*}"}"
        # Ignore empty lines and comments
        if [[ -n "$line" && ! "$line" =~ ^# ]]; then
             # Use eval to properly parse quotes arguments (like shell would)
             eval "PARTS=($line)"
             FILE_ARGS+=("${PARTS[@]}")
        fi
    done < "${TEMP_CONF}/extra-args"
fi

# Combine: File Args first, then CLI args (so CLI overrides File)
if [ ${#FILE_ARGS[@]} -gt 0 ]; then
    # We must reset the positional parameters to the combined list
    set -- "${FILE_ARGS[@]}" "$@"
fi

# 1. Pre-scan for Variant & Override Image
# We need these BEFORE final image resolution to handle branch-specific tags correctly.
VARIANT="latest"
OVERRIDE_IMAGE=""
iter_variant_args=("$@")
for ((i=0; i<${#iter_variant_args[@]}; i++)); do
    case "${iter_variant_args[i]}" in
        --preview) VARIANT="preview" ;;
        --image)   OVERRIDE_IMAGE="${iter_variant_args[i+1]}" ;;
    esac
done

# 2. Resolve Image Name (Local vs Remote)
# Detect Current Branch for dynamic tagging (based on Toolbox repository)
BRANCH_SUFFIX=""
if command -v git >/dev/null 2>&1 && git -C "$REPO_ROOT" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    CURRENT_BRANCH=$(git -C "$REPO_ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [ "$CURRENT_BRANCH" != "main" ] && [ -n "$CURRENT_BRANCH" ]; then
        SAFE_BRANCH="${CURRENT_BRANCH//[!a-zA-Z0-9]/-}"
        BRANCH_SUFFIX="-$SAFE_BRANCH"
    fi
fi

if [ -n "$OVERRIDE_IMAGE" ]; then
    IMAGE_NAME="$OVERRIDE_IMAGE"
elif [ "$VARIANT" == "preview" ]; then
    LOCAL_TAG="gemini-cli-toolbox/cli-preview:latest${BRANCH_SUFFIX}"
    REMOTE_TAG="${DOCKER_HUB_USER}/gemini-cli-toolbox:latest-preview"
else
    LOCAL_TAG="gemini-cli-toolbox/cli:latest${BRANCH_SUFFIX}"
    REMOTE_TAG="${DOCKER_HUB_USER}/gemini-cli-toolbox:latest-stable"
fi

# Check if local image exists
if docker image inspect "$LOCAL_TAG" >/dev/null 2>&1; then
    IMAGE_NAME="$LOCAL_TAG"
else
    # Fallback to remote image
    IMAGE_NAME="$REMOTE_TAG"
fi

# 1. Parse Arguments
ARGS=()
REMOTE_MODE=false
TAILSCALE_KEY="${GEMINI_REMOTE_KEY:-}"
ENABLE_DOCKER=true
DETACHED_MODE=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --preview)     VARIANT="preview"; shift ;;
    --image)       OVERRIDE_IMAGE="$2"; shift; shift ;;
    --no-ide)      ENABLE_VSCODE_INTEGRATION=false;   shift ;;
    --no-docker)   ENABLE_DOCKER=false;               shift ;;
    --config)      HOST_CONF_DIR="$2"; shift; shift ;;
    --profile)     HOST_CONF_DIR="$2"; ENABLE_PROFILE_MODE=true; shift; shift ;;
    --project)     PROJECT_DIR="$2";   shift; shift ;;
    --bash)        USE_BASH=true;      shift ;;
    --detached)    DETACHED_MODE=true; shift ;;
    --remote)      
        REMOTE_MODE=true
        # Optional argument: Check if next arg exists AND starts with 'tskey-'
        if [[ -n "$2" && "$2" == tskey-* ]]; then
            TAILSCALE_KEY="$2"
            shift
        fi
        shift 
        ;;
    --worktree)
        ENABLE_WORKTREE=true
        shift
        ;;
    --name)
        TARGET_NAME="$2"
        shift; shift
        ;;
    --docker-args) 
        read -ra SPLIT_ARGS <<< "$2"
        EXTRA_DOCKER_ARGS+=("${SPLIT_ARGS[@]}")
        shift; shift 
        ;;
    -v|--volume)
        EXTRA_DOCKER_ARGS+=("--volume" "$2")
        shift; shift
        ;;
    --help)        show_help; exit 0 ;;
    update)        FORCE_UPDATE=true; shift ;;
    stop-hub)      STOP_HUB=true; shift ;;
    connect)       CONNECT_ID="$2"; shift; shift ;;
    --)            shift; ARGS+=("$@"); break ;;
    *)             ARGS+=("$1");       shift ;;
  esac
done

# 2. Setup Directories
# HOST_CONF_DIR might be passed as relative or absolute.
# We resolve it to absolute to ensure Docker mounts work correctly.
HOST_CONF_DIR=$(realpath -m "$HOST_CONF_DIR")

# Profile Root Logic (Post-Parse)
# If ENABLE_PROFILE_MODE is true (user passed --config), we treat the path as a "Profile Root".
# The actual Gemini Configuration (history, keys) lives in a '.gemini' subdirectory.
# This keeps the Profile Root clean for extra-args and user files.
PROFILE_ROOT=""
if [ "$ENABLE_PROFILE_MODE" = true ]; then
    PROFILE_ROOT="$HOST_CONF_DIR"
    HOST_CONF_DIR="${HOST_CONF_DIR}/.gemini"
fi
mkdir -p "$HOST_CONF_DIR"

# 2.1 Pre-create Host Cache Directories (As User)
# We do this to prevent Docker from creating them as 'root' if they don't exist
REQUIRED_DIRS=(
    "${HOME}/.m2"
    "${HOME}/.gradle"
    "${HOME}/.sbt"
    "${HOME}/.ivy2"
    "${HOME}/.cache/coursier"
    "${HOME}/go/pkg/mod"
    "${HOME}/.cache/go-build"
)

for dir in "${REQUIRED_DIRS[@]}"; do
    if [ ! -d "$dir" ]; then
        # echo "Initializing missing cache directory: $dir"
        mkdir -p "$dir"
    fi
done

PROJECT_DIR=$(realpath -m "$PROJECT_DIR")
if [ ! -d "$PROJECT_DIR" ]; then
    echo "Error: Project directory '$PROJECT_DIR' does not exist." >&2
    exit 1
fi

# Extract project name for prettier mount point.
# We sanitize it to ensure it is a valid DNS label (only alphanumeric and hyphens).
PROJECT_NAME=$(basename "$PROJECT_DIR" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')

# Determine Session Type for Remote Access / Analytics
SESSION_TYPE="geminicli"
if [ "$USE_BASH" = true ]; then
    SESSION_TYPE="bash"
fi

# Generate readable unique container name
# Format: {PROJECT}-{TYPE}-{UUID}
# We pass this ID to the container so it can use it for the Tailscale Hostname
# ensuring 1:1 mapping between Container Name and VPN Name.
if [ -f /proc/sys/kernel/random/uuid ]; then
    GEN_UUID=$(head -c 36 /proc/sys/kernel/random/uuid | cut -c1-8)
fi
# Ensure UUID is set even if /proc is missing (unlikely on Linux)
GEN_UUID="${GEN_UUID:-$(date +%s)}"

GEMINI_SESSION_ID="gem-${PROJECT_NAME}-${SESSION_TYPE}-${GEN_UUID}"
CONTAINER_NAME_ARG=("--name" "${GEMINI_SESSION_ID}")

# 2.2.1 Setup Worktree (if requested)
ORIGINAL_PROJECT_DIR="$PROJECT_DIR"
if [ "$ENABLE_WORKTREE" = true ]; then
    setup_worktree
fi

# 2.3 Handle Explicit Update
if [ "$FORCE_UPDATE" = true ]; then
    if [[ "$IMAGE_NAME" == "$LOCAL_TAG" ]]; then
        echo ">> Error: You are using a local image '$LOCAL_TAG'. Cannot update from registry."
        echo ">> Run 'make rebuild' to update locally."
        exit 1
    fi
    echo ">> Updating '$IMAGE_NAME'..."
    docker pull "$IMAGE_NAME"
    exit $?
fi

# 2.4 Handle Hub Stop
if [ "$STOP_HUB" = true ]; then
    # Use the already resolved SCRIPT_DIR
    HUB_SCRIPT="${SCRIPT_DIR}/gemini-hub"
    if [ -x "$HUB_SCRIPT" ]; then
         exec "$HUB_SCRIPT" stop
    else
         echo "Error: gemini-hub script not found."
         exit 1
    fi
fi

# 2.5 Handle Connect
if [ -n "$CONNECT_ID" ]; then
    echo ">> Connecting to session '$CONNECT_ID'..."
    # Use current user's UID
    CURRENT_UID=$(id -u)
    
    if [[ "$CONNECT_ID" == *"-bash-"* ]]; then
         echo ">> Opening Bash shell..."
         exec docker exec -it "$CONNECT_ID" gosu "$CURRENT_UID" bash
    else
         exec docker exec -it "$CONNECT_ID" gosu "$CURRENT_UID" tmux attach -t gemini
    fi
fi

# 2.6 Stale Image Warning
# Only if using remote image, it is a 'latest' tag, AND it is > 7 days old
if [[ "$IMAGE_NAME" == *"$REMOTE_TAG"* ]] && [[ "$IMAGE_NAME" == *"latest"* ]] && docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
    CREATED=$(docker inspect --format='{{.Created}}' "$IMAGE_NAME")
    CREATED_SEC=$(date -d "$CREATED" +%s 2>/dev/null || echo "0")
    NOW_SEC=$(date +%s)
    AGE=$(( (NOW_SEC - CREATED_SEC) / 86400 ))
    
    # 7 days
    if [ "$AGE" -ge 7 ]; then
         echo ">> Tip: Your Gemini image is $AGE days old. Run 'gemini-toolbox update' to refresh."
    fi
fi

# 2.7 Detect Host Docker GID (for DooD)
if [ "$ENABLE_DOCKER" = true ] && [ -z "$HOST_DOCKER_GID" ]; then
    if command -v getent >/dev/null 2>&1 && getent group docker >/dev/null 2>&1; then
        HOST_DOCKER_GID=$(getent group docker | cut -d: -f3)
    fi
fi

# 3. Build Docker Command
NETWORK_MODE="--net=host"
if [ "$REMOTE_MODE" = true ]; then
    if [ -z "$TAILSCALE_KEY" ]; then
        echo "Error: --remote specified but no Tailscale Key found."
        echo "Provide key via argument (--remote tskey-...) or environment (GEMINI_REMOTE_KEY)."
        exit 1
    fi
    echo ">> Remote Mode detected. Isolating network stack..."

    # Auto-start Gemini Hub (for mobile discovery)
    HUB_NAME="gemini-hub-service"
    # Check if container is running by looking for non-empty ID output
    # Use anchor ^...$ to match exact name
    if [ -z "$(docker ps -q -f name="^/${HUB_NAME}$")" ]; then
    # Use the already resolved SCRIPT_DIR
    HUB_SCRIPT="${SCRIPT_DIR}/gemini-hub"
        if [ -x "$HUB_SCRIPT" ]; then
             echo ">> Auto-starting Gemini Hub..."
             echo "   (Stop with: gemini-toolbox stop-hub)"
             
             HUB_ARGS=("-d" "--key" "$TAILSCALE_KEY" "--workspace" "$PROJECT_DIR")
             
             # If running in Profile Mode, ask user if they want to expose the parent directory to the Hub
             if [ "$ENABLE_PROFILE_MODE" = true ] && [ -n "$PROFILE_ROOT" ]; then
                 HUB_CONFIG_ROOT=$(dirname "$PROFILE_ROOT")
                 
                 # Only ask if interactive. If NOT interactive, we don't share the parent.
                 if [ -t 0 ]; then
                     echo ""
                     echo ">> Profile Mode detected: ${PROFILE_ROOT}"
                     echo ">> The Hub can scan the parent directory (${HUB_CONFIG_ROOT}) to let you switch profiles easily."
                     read -p ">> Allow Hub to scan parent directory? [y/N] " -n 1 -r
                     echo ""
                     if [[ $REPLY =~ ^[Yy]$ ]]; then
                         HUB_ARGS+=("--config-root" "$HUB_CONFIG_ROOT")
                     fi
                 fi
             fi
             
             if "$HUB_SCRIPT" "${HUB_ARGS[@]}" > /tmp/gemini-hub.log 2>&1; then
                 echo ">> Hub started."
             else
                 echo ">> Warning: Failed to start Hub. Check /tmp/gemini-hub.log"
             fi
        else
             echo ">> Warning: gemini-hub script not found at $HUB_SCRIPT"
        fi
    else
         echo ">> Gemini Hub is active at http://localhost:8888"
    fi

    NETWORK_MODE="--network=bridge"
    ENABLE_VSCODE_INTEGRATION=false
    EXTRA_DOCKER_ARGS+=(
        --env TAILSCALE_AUTH_KEY="$TAILSCALE_KEY"
        --cap-add=NET_ADMIN
        --device /dev/net/tun
        # Hybrid Mode: Expose port 3000 to localhost (host)
        # This allows the user to browse http://localhost:<random_port> on the host machine
        # and hit the app running on port 3000 inside the container (on the VPN).
        -p 127.0.0.1:0:3000
    )
fi

DOCKER_ARGS=(
  "${CONTAINER_NAME_ARG[@]}"
  "$NETWORK_MODE"
  # Path Mirroring for IDE Security Check:
  # We mount the project at the EXACT SAME path as the host (not /home/gemini/workspace).
  # The Gemini CLI checks that PWD inside match the Workspace Path in VS Code.
  --volume "${PROJECT_DIR}:${PROJECT_DIR}"
  )

  # --- Parent Repo Mounting Strategy ---
  # Only mount parent if we are in a worktree (PROJECT_DIR != ORIGINAL_PROJECT_DIR)
  if [ "$PROJECT_DIR" != "$ORIGINAL_PROJECT_DIR" ]; then
      # We need the parent repo for Git history/objects.
      # We mount Parent :ro for security, but .git :rw for Git functionality.
      DOCKER_ARGS+=(
          --volume "${ORIGINAL_PROJECT_DIR}:${ORIGINAL_PROJECT_DIR}:ro"
          --volume "${ORIGINAL_PROJECT_DIR}/.git:${ORIGINAL_PROJECT_DIR}/.git"
      )
  fi

  DOCKER_ARGS+=(
    --volume "${HOST_CONF_DIR}:/home/gemini/.gemini"
    # Shared Host Caches (Performance & Convenience)
    --volume "${HOME}/.m2:/home/gemini/.m2"
    --volume "${HOME}/.gradle:/home/gemini/.gradle"
    --volume "${HOME}/.sbt:/home/gemini/.sbt"
    --volume "${HOME}/.ivy2:/home/gemini/.ivy2"
    --volume "${HOME}/.cache/coursier:/home/gemini/.cache/coursier"
    --volume "${HOME}/go/pkg/mod:/home/gemini/go/pkg/mod"
    --volume "${HOME}/.cache/go-build:/home/gemini/.cache/go-build"
    --env DEFAULT_UID="${HOST_UID:-$(id -u)}"
    --env DEFAULT_GID="${HOST_GID:-$(id -g)}"
    --env GEMINI_SESSION_ID="${GEMINI_SESSION_ID}"
    --env GEMINI_PROJECT_NAME="${PROJECT_NAME}"
    --env GEMINI_SESSION_TYPE="${SESSION_TYPE}"
    --env TERM="${TERM:-xterm-256color}"
    --env COLORTERM
    --env LANG
    --env LC_ALL
    --env HTTP_PROXY --env HTTPS_PROXY --env NO_PROXY
    --env http_proxy --env https_proxy --env no_proxy
    --workdir "${PROJECT_DIR}"
    "${EXTRA_DOCKER_ARGS[@]}"
  )

# Conditionally Add Docker Support
if [ "$ENABLE_DOCKER" = true ]; then
    DOCKER_ARGS+=(
      # Docker-out-of-Docker Support
      --volume "/var/run/docker.sock:/var/run/docker.sock"
      --env HOST_DOCKER_GID="${HOST_DOCKER_GID}"
    )
else
    echo ">> Warning: Docker-out-of-Docker integration is disabled (--no-docker)."
fi

# Conditionally Add IDE Integration
if [ "$ENABLE_VSCODE_INTEGRATION" = true ]; then
    DOCKER_ARGS+=(
      # VS Code Integration:
      # 1. TERM_PROGRAM*: Tells Gemini CLI we are inside VS Code (enables the feature).
      # 2. GEMINI_CLI_IDE_*: Connection details passed from the Host Terminal.
      #    - HOST=127.0.0.1: Our custom patch forces the CLI to use this instead of host.docker.internal.
      --env TERM_PROGRAM
      --env TERM_PROGRAM_VERSION
      --env GEMINI_CLI_IDE_SERVER_PORT
      --env GEMINI_CLI_IDE_AUTH_TOKEN
      --env GEMINI_CLI_IDE_WORKSPACE_PATH
      --env GEMINI_CLI_IDE_SERVER_HOST=127.0.0.1
    )
fi

# 4. Assemble Execution Arguments
EXEC_ARGS=()
if [ "$USE_BASH" = true ]; then
    echo ">> Mode: BASH"
    EXEC_ARGS=("--entrypoint" "/usr/local/bin/docker-entrypoint.sh" "$IMAGE_NAME" "bash" "${ARGS[@]}")
else
    EXEC_ARGS=("$IMAGE_NAME" "${ARGS[@]}")
fi

# 5. Execute
if [ "$DETACHED_MODE" = true ]; then
    echo ">> Starting container in background..."
    docker run --rm -d "${DOCKER_ARGS[@]}" "${EXEC_ARGS[@]}"
    echo ">> Container started: ${GEMINI_SESSION_ID}"
else
    if [ "$USE_BASH" = true ]; then
        echo "Starting in BASH mode..."
    fi
    docker run --rm -it "${DOCKER_ARGS[@]}" "${EXEC_ARGS[@]}"
fi